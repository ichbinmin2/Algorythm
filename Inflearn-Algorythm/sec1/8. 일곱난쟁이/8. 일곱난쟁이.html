<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      function solution(arr) {
        /* 얕은 복사 : answer에 arr 주소만 복사해서 넣어놨다. */
        let answer = arr;

        /* 이중 for 문을 돌면서 확인해야 한다.
         * 일곱 난쟁이의 합은 100이다. => 7*arr[i] === 100
         * 주어진 배열 안의 갯수는 7이 아니라 9이다. => 9
         */

        /** 이제 arr의 총합을 구한다. => reduce 메소드를 사용하면 편리하다. */
        let sum = arr.reduce((acc, val) => acc + val, 0);

        for (let i = 0; i < 8; i++) {
          // 0번 index 부터 돌고, index가 원본 배열 요소의 [8]까지만 반복문이 돌도록 한다.
          // ==> 길이가 정해져 있지 않을 경우 arr.length로 돌아도 된다.
          for (let j = i + 1; j < 9; j++) {
            if (sum - (answer[i] + answer[j]) === 100) {
              /* 만약if (총합 - arr[i] + arr[j] === 100) 이면
               * arr[i]와 arr[j]는 가짜 난쟁이이다.
               * => 이 가짜 난쟁이를 걸러낸 값이 100이기 때문에 if 문을 사용해서 걸러낸다.
               */

              answer.splice(j, 1); // j를 먼저 삭제해야 index 값이 정상적으로 삭제된다.
              answer.splice(i, 1); // 다음으로 i를 삭제해야 index 값이 정상적으로 삭제된다.
              /* 그리고,
               * 해당 원본배열을 그대로 복사한 값인 answer 배열에
               * 이 가짜 난쟁이 i 와 j 를 삭제하고 내보내야 하므로,
               * splice 를 사용해서 해당 배열 요소를 삭제한다.
               */

              return answer;
              // 쓸데없는 반복 연산을 피하기 위해 바로 answer를 여기서 리턴했다.
              // 강의 영상 해설과 다르지만, 커뮤니티 글을 보고 수정했다.
            }
          }
        }
        // return answer;
      }

      let arr = [20, 7, 23, 19, 10, 15, 25, 8, 13];
      console.log(solution(arr));
    </script>
  </body>
</html>
